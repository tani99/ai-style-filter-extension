// Content script for AI Style-Based Shopping Filter + Virtual Try-On
console.log('AI Style Filter content script loaded');

// Step 4.1: Content Script Injection System
class StyleFilterContentScript {
    constructor() {
        this.currentHost = window.location.hostname;
        this.currentUrl = window.location.href;
        this.supportedSites = {
            'zara.com': {
                name: 'Zara',
                productPagePatterns: ['/product/', '/p/', '/item/'],
                categoryPagePatterns: ['/category/', '/c/', '/shop/'],
                isClothingSite: true,
                selectors: {
                    productImages: [
                        '.media-image img',
                        '.product-detail-images img',
                        '.product-media img',
                        '.gallery-image img',
                        'img[data-testid*="image"]'
                    ],
                    productCards: [
                        '.product-card',
                        '.product-item',
                        '.grid-card',
                        '[data-testid="product"]'
                    ],
                    productLinks: [
                        'a[href*="/product/"]',
                        'a[href*="/p/"]',
                        '.product-link'
                    ]
                }
            },
            'hm.com': {
                name: 'H&M',
                productPagePatterns: ['/product/', '/p/', '/item/'],
                categoryPagePatterns: ['/category/', '/c/', '/shop/', '/women/', '/men/', '/kids/'],
                isClothingSite: true,
                selectors: {
                    productImages: [
                        '.product-detail-main-image img',
                        '.product-item img',
                        '.hm-product-item img',
                        '.item-image img',
                        'img[data-src*="product"]'
                    ],
                    productCards: [
                        '.product-item',
                        '.hm-product-item',
                        '.item-link',
                        '.product-card'
                    ],
                    productLinks: [
                        'a[href*="/product/"]',
                        'a[href*="/p/"]',
                        '.item-link'
                    ]
                }
            },
            'nike.com': {
                name: 'Nike',
                productPagePatterns: ['/product/', '/p/', '/item/', '/t/'],
                categoryPagePatterns: ['/category/', '/c/', '/shop/', '/men/', '/women/', '/kids/'],
                isClothingSite: true,
                selectors: {
                    productImages: [
                        '.product-image img',
                        '.hero-image img',
                        '.pdp-image img',
                        'img[data-sub*="product"]',
                        '.wall-image img'
                    ],
                    productCards: [
                        '.product-card',
                        '.product-tile',
                        '.grid-product-card',
                        '[data-testid*="product"]'
                    ],
                    productLinks: [
                        'a[href*="/t/"]',
                        'a[href*="/product/"]',
                        '.product-card-link'
                    ]
                }
            }
        };
        
        this.currentSite = this.detectCurrentSite();
        this.pageType = this.detectPageType();
        
        console.log('üîç Site Detection:', {
            host: this.currentHost,
            site: this.currentSite,
            pageType: this.pageType,
            url: this.currentUrl
        });
        
        if (this.currentSite) {
            this.initialize();
        } else {
            console.log(`AI Style Filter not active on ${this.currentHost}`);
        }
    }
    
    detectCurrentSite() {
        for (const [domain, config] of Object.entries(this.supportedSites)) {
            if (this.currentHost.includes(domain)) {
                return { domain, ...config };
            }
        }
        return null;
    }
    
    detectPageType() {
        if (!this.currentSite) return 'unknown';
        
        const url = this.currentUrl.toLowerCase();
        
        // Check for product pages
        for (const pattern of this.currentSite.productPagePatterns) {
            if (url.includes(pattern)) {
                return 'product';
            }
        }
        
        // Check for category/listing pages
        for (const pattern of this.currentSite.categoryPagePatterns) {
            if (url.includes(pattern)) {
                return 'category';
            }
        }
        
        // Check for search pages
        if (url.includes('search') || url.includes('query') || url.includes('q=')) {
            return 'search';
        }
        
        // Default to homepage or other
        return 'other';
    }
    
    initialize() {
        console.log(`‚úÖ AI Style Filter initializing on ${this.currentSite.name}`);
        console.log(`üìÑ Page Type: ${this.pageType}`);

        // Initialize style analysis cache and performance tracking
        this.initializeStyleAnalysis();

        // Initialize based on page type
        this.initializeForPageType();

        // Add visual indicator
        this.addExtensionIndicator();

        // Set up message listeners
        this.setupMessageListeners();

        // Handle dynamic content loading (SPA navigation)
        this.setupNavigationListener();

        // Set up lazy loading detection
        this.setupLazyLoadingDetection();

        // Notify background script
        this.notifyBackgroundScript();
    }

    // Step 5.1: Initialize Real-time Product Analysis System
    initializeStyleAnalysis() {
        console.log('üé® Initializing style analysis system...');

        // Cache for product analysis results to avoid re-analyzing same products
        this.analysisCache = new Map();

        // Performance tracking
        this.activeAnalyses = 0;
        this.maxConcurrentAnalyses = 6; // Increased for faster processing
        this.analysisQueue = [];

        // Viewport-based analysis
        this.processedImages = new Set(); // Track which images we've already processed
        this.viewportAnalysisEnabled = true;
        this.setupViewportAnalysis();

        // User's style profile (will be loaded from storage)
        this.userStyleProfile = null;

        // Track analysis statistics
        this.analysisStats = {
            totalAnalyzed: 0,
            cacheHits: 0,
            apiCalls: 0,
            averageScore: 0,
            failures: 0,
            consecutiveFailures: 0
        };

        // Circuit breaker to prevent excessive failed requests
        this.circuitBreakerThreshold = 5; // Stop after 5 consecutive failures
        this.circuitBreakerOpen = false;

        // Load user's style profile from storage
        this.loadUserStyleProfile();
    }

    async loadUserStyleProfile() {
        try {
            const result = await chrome.storage.local.get(['styleProfile']);
            if (result.styleProfile) {
                this.userStyleProfile = result.styleProfile;
                console.log('üìã Style profile loaded for product analysis:', {
                    colors: this.userStyleProfile.color_palette?.best_colors?.length || 0,
                    styles: this.userStyleProfile.style_categories?.length || 0,
                    generated: new Date(this.userStyleProfile.generated_at).toLocaleDateString()
                });
            } else {
                console.log('‚ö†Ô∏è No style profile found - product analysis will be limited');
            }
        } catch (error) {
            console.error('Failed to load style profile:', error);
        }
    }

    // Setup viewport-based analysis system
    setupViewportAnalysis() {
        // Use Intersection Observer to analyze images as they come into view
        if ('IntersectionObserver' in window) {
            this.analysisObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.target.tagName === 'IMG') {
                        const img = entry.target;
                        const imgKey = this.getImageKey(img);
                        const cacheKey = this.generateProductCacheKey(img, this.userStyleProfile);

                        // Check if it's a detected clothing image
                        if (img.dataset.aiStyleDetected === 'true') {
                            // If we have cached results, apply them immediately
                            if (this.analysisCache.has(cacheKey) && !this.processedImages.has(imgKey)) {
                                console.log('üíæ Restoring cached analysis for re-entered image:', img.alt || 'no alt');
                                this.processedImages.add(imgKey);
                                this.analyzeImageOnDemand(img); // This will use cache
                            }
                            // Only analyze if we haven't processed this image yet
                            else if (!this.processedImages.has(imgKey)) {
                                this.processedImages.add(imgKey);
                                this.analyzeImageOnDemand(img);
                            }
                        }
                    }
                });
            }, {
                rootMargin: '100px', // Start analyzing 100px before image enters viewport
                threshold: 0.1 // Trigger when 10% visible
            });
        }
    }

    // Get unique key for an image to avoid duplicates
    getImageKey(img) {
        return `${img.src || ''}|${img.alt || ''}|${img.className || ''}`;
    }

    // Analyze a single image on demand (when it enters viewport)
    async analyzeImageOnDemand(img) {
        if (!this.userStyleProfile) return;

        const imgKey = this.getImageKey(img);
        const cacheKey = this.generateProductCacheKey(img, this.userStyleProfile);

        // Check if we already have analysis for this image (deterministic caching)
        if (this.analysisCache.has(cacheKey)) {
            console.log('üíæ Using cached analysis for viewport image:', img.alt || 'no alt');

            // Find the detected item and apply cached analysis
            if (this.detectedProducts) {
                const detectedItem = this.detectedProducts.find(item => item.element === img);
                if (detectedItem && !detectedItem.styleAnalysis) {
                    detectedItem.styleAnalysis = this.analysisCache.get(cacheKey);

                    // Update visual indicators with cached data
                    this.updateSingleImageIndicators(detectedItem, this.detectedProducts.indexOf(detectedItem));
                }
            }
            return;
        }

        console.log('üëÅÔ∏è Analyzing image as it enters viewport:', img.alt || 'no alt');

        try {
            const analysis = await this.analyzeProduct(img);

            // Find the detected item and add analysis
            if (this.detectedProducts) {
                const detectedItem = this.detectedProducts.find(item => item.element === img);
                if (detectedItem) {
                    detectedItem.styleAnalysis = analysis;

                    // Update visual indicators for this specific image
                    this.updateSingleImageIndicators(detectedItem, this.detectedProducts.indexOf(detectedItem));
                }
            }
        } catch (error) {
            console.warn('Error analyzing image on demand, skipping:', error.message);
            // Don't throw error - just skip this image analysis
        }
    }

    // Update visual indicators for a single image
    updateSingleImageIndicators(item, index) {
        const img = item.element;

        // Remove existing overlays for this image
        const existingOverlays = document.querySelectorAll(`[data-ai-style-target-index="${index}"]`);
        existingOverlays.forEach(overlay => overlay.remove());

        // Re-add with updated styling
        this.addSingleImageIndicator(item, index);
    }

    // Add visual indicator for a single image (extracted from addVisualIndicators)
    addSingleImageIndicator(item, index) {
        const img = item.element;
        const hasStyleAnalysis = item.styleAnalysis;

        // Determine border color based on style score
        let borderColor = '#10b981'; // Default green
        let borderWidth = '3px';
        let glowColor = 'rgba(16, 185, 129, 0.6)';

        if (hasStyleAnalysis) {
            const score = item.styleAnalysis.score;
            if (score >= 8) {
                borderColor = '#059669'; // Darker green for high scores
                glowColor = 'rgba(5, 150, 105, 0.8)';
                borderWidth = '4px';
            } else if (score >= 6) {
                borderColor = '#10b981'; // Standard green
                glowColor = 'rgba(16, 185, 129, 0.6)';
            } else if (score >= 4) {
                borderColor = '#f59e0b'; // Orange for medium scores
                glowColor = 'rgba(245, 158, 11, 0.6)';
            } else {
                borderColor = '#ef4444'; // Red for low scores
                glowColor = 'rgba(239, 68, 68, 0.6)';
            }
        }

        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'ai-style-detected-overlay';
        overlay.style.cssText = `
            position: absolute;
            pointer-events: none;
            border: ${borderWidth} solid ${borderColor};
            border-radius: 6px;
            box-shadow: 0 0 15px ${glowColor};
            z-index: 10000;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
        `;

        this.positionOverlay(overlay, img);
        overlay.dataset.aiStyleOverlay = 'detected';
        overlay.dataset.aiStyleTargetIndex = index;

        // Create score badge if analysis is available
        if (hasStyleAnalysis) {
            const scoreBadge = document.createElement('div');
            let badgeColor = '#10b981';
            if (item.styleAnalysis.score >= 8) badgeColor = '#059669';
            else if (item.styleAnalysis.score >= 6) badgeColor = '#10b981';
            else if (item.styleAnalysis.score >= 4) badgeColor = '#f59e0b';
            else badgeColor = '#ef4444';

            scoreBadge.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: ${badgeColor};
                color: white;
                border-radius: 50%;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 11px;
                font-weight: bold;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                z-index: 10001;
                pointer-events: none;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            `;
            scoreBadge.textContent = `${item.styleAnalysis.score}`;

            this.positionScoreBadge(scoreBadge, img);
            scoreBadge.dataset.aiStyleOverlay = 'score-badge';
            scoreBadge.dataset.aiStyleTargetIndex = index;
            document.body.appendChild(scoreBadge);

            const updateBadgePosition = () => this.positionScoreBadge(scoreBadge, img);
            window.addEventListener('scroll', updateBadgePosition);
            window.addEventListener('resize', updateBadgePosition);
        }

        // Enhanced tooltip
        let tooltipText = `AI Style Filter: Detected clothing image
Method: ${item.method}
Reason: ${item.reasoning}`;

        if (hasStyleAnalysis) {
            tooltipText += `
Style Score: ${item.styleAnalysis.score}/10 (${Math.round(item.styleAnalysis.confidence * 100)}% confidence)
Analysis: ${item.styleAnalysis.reasoning}`;
        }

        img.title = tooltipText;
        document.body.appendChild(overlay);

        const updatePosition = () => this.positionOverlay(overlay, img);
        window.addEventListener('scroll', updatePosition);
        window.addEventListener('resize', updatePosition);
    }

    // Check if element is currently in viewport
    isElementInViewport(element) {
        const rect = element.getBoundingClientRect();
        const windowHeight = window.innerHeight || document.documentElement.clientHeight;
        const windowWidth = window.innerWidth || document.documentElement.clientWidth;

        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= windowHeight &&
            rect.right <= windowWidth &&
            rect.width > 0 &&
            rect.height > 0
        );
    }

    // Control methods for viewport analysis
    enableViewportAnalysis() {
        this.viewportAnalysisEnabled = true;
        console.log('üì∫ Viewport-based analysis enabled');
    }

    disableViewportAnalysis() {
        this.viewportAnalysisEnabled = false;
        if (this.analysisObserver) {
            this.analysisObserver.disconnect();
        }
        console.log('üì∫ Viewport-based analysis disabled');
    }

    // Debug method to check queue status
    debugAnalysisQueue() {
        console.log('üîç Analysis Queue Debug:', {
            queueLength: this.analysisQueue.length,
            activeAnalyses: this.activeAnalyses,
            maxConcurrent: this.maxConcurrentAnalyses,
            processedImages: this.processedImages.size,
            cacheSize: this.analysisCache.size,
            detectedProducts: this.detectedProducts?.length || 0
        });

        if (this.analysisQueue.length > 0) {
            console.log('üì• Queue items (first 5):');
            this.analysisQueue.slice(0, 5).forEach((item, index) => {
                console.log(`  ${index + 1}. ${item.productImage.alt || 'no alt'} (${item.productImage.src?.slice(-30) || 'no src'})`);
            });
        }

        return {
            queueLength: this.analysisQueue.length,
            activeAnalyses: this.activeAnalyses,
            processedImages: this.processedImages.size
        };
    }

    // Clear all processing state (useful for debugging)
    resetAnalysisState() {
        this.analysisQueue = [];
        this.processedImages.clear();
        this.activeAnalyses = 0;
        this.clearAnalysisCache();

        if (this.analysisObserver) {
            this.analysisObserver.disconnect();
            this.setupViewportAnalysis();
        }

        console.log('üîÑ Analysis state reset');
    }

    // Reset circuit breaker manually
    resetCircuitBreaker() {
        this.circuitBreakerOpen = false;
        this.analysisStats.consecutiveFailures = 0;
        console.log('‚ö° Circuit breaker manually reset');
    }

    // Check if chrome.runtime connection is available
    isRuntimeAvailable() {
        try {
            return !!(chrome && chrome.runtime && chrome.runtime.id);
        } catch (error) {
            return false;
        }
    }

    // Safe message sending with error handling
    async safeSendMessage(message, timeoutMs = 8000) {
        return new Promise((resolve, reject) => {
            if (!this.isRuntimeAvailable()) {
                reject(new Error('Chrome runtime not available'));
                return;
            }

            const timeout = setTimeout(() => {
                reject(new Error('Message timeout'));
            }, timeoutMs);

            try {
                chrome.runtime.sendMessage(message, (response) => {
                    clearTimeout(timeout);

                    if (chrome.runtime.lastError) {
                        reject(new Error(`Runtime error: ${chrome.runtime.lastError.message}`));
                        return;
                    }

                    if (!response) {
                        reject(new Error('No response received'));
                        return;
                    }

                    resolve(response);
                });
            } catch (error) {
                clearTimeout(timeout);
                reject(error);
            }
        });
    }

    // Step 5.1: Core Product Analysis Function
    async analyzeProduct(productImage, userProfile = null) {
        // Use provided profile or fallback to instance profile
        const profile = userProfile || this.userStyleProfile;

        if (!profile) {
            console.log('‚ö†Ô∏è No style profile available - skipping product analysis');
            return {
                score: 5, // Neutral score when no profile
                reasoning: 'No style profile available for analysis',
                method: 'no_profile',
                confidence: 0
            };
        }

        // Generate cache key for this product
        const cacheKey = this.generateProductCacheKey(productImage, profile);

        // Check cache first
        if (this.analysisCache.has(cacheKey)) {
            this.analysisStats.cacheHits++;
            console.log('üíæ Using cached analysis result');
            return this.analysisCache.get(cacheKey);
        }

        // Check if we can start a new analysis (performance limiting)
        if (this.activeAnalyses >= this.maxConcurrentAnalyses) {
            // Safety check: prevent queue from growing too large
            const maxQueueSize = 200;
            if (this.analysisQueue.length >= maxQueueSize) {
                console.warn(`‚ö†Ô∏è Analysis queue full (${maxQueueSize} items), dropping request for safety`);
                return {
                    score: 5,
                    reasoning: 'Analysis queue full - skipped for performance',
                    confidence: 0,
                    method: 'queue_full'
                };
            }

            // Add to queue for later processing
            return new Promise((resolve) => {
                this.analysisQueue.push({
                    productImage,
                    userProfile: profile,
                    resolve,
                    cacheKey
                });
                console.log(`üì• Analysis queued (${this.analysisQueue.length} in queue)`);
            });
        }

        return this.performProductAnalysis(productImage, profile, cacheKey);
    }

    async performProductAnalysis(productImage, profile, cacheKey) {
        this.activeAnalyses++;
        this.analysisStats.apiCalls++;

        const imageInfo = this.getImageInfo(productImage);
        console.log(`üîç Analyzing product compatibility (${this.activeAnalyses}/${this.maxConcurrentAnalyses} active): "${imageInfo.alt}"`);

        // Circuit breaker check
        if (this.circuitBreakerOpen) {
            console.warn('‚ö° Circuit breaker open - using fallback analysis');
            const fallbackResult = this.fallbackProductAnalysis(productImage, profile);
            this.analysisCache.set(cacheKey, fallbackResult);
            return fallbackResult;
        }

        try {
            // Create analysis prompt with user's style profile
            const analysisPrompt = this.createProductAnalysisPrompt(productImage, profile);

            // Send to Chrome AI via background script with safe error handling
            let response;
            try {
                response = await this.safeSendMessage({
                    action: 'aiPrompt',
                    prompt: analysisPrompt,
                    options: {
                        temperature: 0.3, // Lower temperature for consistent scoring
                        maxRetries: 0 // No retries for faster processing
                    }
                }, 5000); // 5 second timeout
            } catch (error) {
                console.warn('AI request failed, using fallback:', error.message);
                response = { success: false, error: error.message };
            }

            let result;
            if (response.success) {
                result = this.parseProductAnalysisResponse(response.response);
                console.log(`‚úÖ Product analysis complete: Score ${result.score}/10 (${result.method})`);

                // Reset circuit breaker on success
                this.analysisStats.consecutiveFailures = 0;
                if (this.circuitBreakerOpen) {
                    this.circuitBreakerOpen = false;
                    console.log('‚ö° Circuit breaker reset - AI requests restored');
                }
            } else {
                // Fallback analysis if AI fails
                result = this.fallbackProductAnalysis(productImage, profile);
                console.log(`‚ö†Ô∏è AI analysis failed, using fallback: ${response.error}`);

                // Update failure tracking
                this.analysisStats.failures++;
                this.analysisStats.consecutiveFailures++;

                // Check if we should open circuit breaker
                if (this.analysisStats.consecutiveFailures >= this.circuitBreakerThreshold) {
                    this.circuitBreakerOpen = true;
                    console.warn(`‚ö° Circuit breaker opened after ${this.circuitBreakerThreshold} consecutive failures`);
                }
            }

            // Cache the result
            this.analysisCache.set(cacheKey, result);

            // Update statistics
            this.analysisStats.totalAnalyzed++;
            this.analysisStats.averageScore =
                (this.analysisStats.averageScore * (this.analysisStats.totalAnalyzed - 1) + result.score) /
                this.analysisStats.totalAnalyzed;

            return result;

        } catch (error) {
            console.warn('Product analysis error, using fallback:', error.message);

            // Update failure tracking
            this.analysisStats.failures++;
            this.analysisStats.consecutiveFailures++;

            // Return fallback result instead of throwing
            const fallbackResult = this.fallbackProductAnalysis(productImage, profile);

            // Cache the fallback result to avoid retrying
            this.analysisCache.set(cacheKey, fallbackResult);

            // Update statistics
            this.analysisStats.totalAnalyzed++;

            return fallbackResult;
        } finally {
            this.activeAnalyses--;

            // Process next item in queue
            if (this.analysisQueue.length > 0 && this.activeAnalyses < this.maxConcurrentAnalyses) {
                const next = this.analysisQueue.shift();
                next.resolve(this.performProductAnalysis(next.productImage, next.userProfile, next.cacheKey));
            }
        }
    }

    createProductAnalysisPrompt(productImage, profile) {
        // Extract key profile information
        const colors = profile.color_palette?.best_colors || [];
        const styles = profile.style_categories?.map(cat => `${cat.name} (${cat.confidence})`) || [];
        const avoidColors = profile.color_palette?.avoid_colors || [];
        const patterns = profile.pattern_preferences?.recommended_patterns || [];
        const aesthetic = profile.overall_aesthetic?.keywords || [];

        // Get image context
        const imageInfo = this.getImageInfo(productImage);
        const alt = imageInfo.alt || 'clothing item';

        return `Rate this clothing item's compatibility with this user's style profile on a scale of 1-10.

USER STYLE PROFILE:
- Preferred Colors: ${colors.join(', ')}
- Style Categories: ${styles.join(', ')}
- Avoid Colors: ${avoidColors.join(', ')}
- Pattern Preferences: ${patterns.join(', ')}
- Aesthetic Keywords: ${aesthetic.join(', ')}

PRODUCT TO ANALYZE:
- Item Description: "${alt}"
- Context: E-commerce product image

SCORING CRITERIA:
- Color harmony with preferred palette (40%)
- Style category match (30%)
- Pattern compatibility (20%)
- Overall aesthetic alignment (10%)

Respond with ONLY this format:
SCORE: [1-10]
REASONING: [2-3 sentences explaining the score]
CONFIDENCE: [0.1-1.0]

Example:
SCORE: 8
REASONING: This navy blazer aligns perfectly with the user's classic style preference and matches their preferred color palette. The structured silhouette fits their professional aesthetic.
CONFIDENCE: 0.9`;
    }

    parseProductAnalysisResponse(response) {
        try {
            const scoreMatch = response.match(/SCORE:\s*(\d+(?:\.\d+)?)/i);
            const reasoningMatch = response.match(/REASONING:\s*(.+?)(?=\nCONFIDENCE:|$)/is);
            const confidenceMatch = response.match(/CONFIDENCE:\s*(\d*\.?\d+)/i);

            const score = scoreMatch ? Math.min(10, Math.max(1, parseFloat(scoreMatch[1]))) : 5;
            const reasoning = reasoningMatch ? reasoningMatch[1].trim() : 'Product analyzed for style compatibility';
            const confidence = confidenceMatch ? Math.min(1, Math.max(0.1, parseFloat(confidenceMatch[1]))) : 0.7;

            return {
                score: Math.round(score),
                reasoning: reasoning,
                confidence: confidence,
                method: 'ai_analysis',
                rawResponse: response
            };
        } catch (error) {
            console.error('Failed to parse analysis response:', error);
            return {
                score: 5,
                reasoning: 'Analysis parsing failed',
                confidence: 0.3,
                method: 'parse_error',
                rawResponse: response
            };
        }
    }

    fallbackProductAnalysis(productImage, profile) {
        // Simple rule-based analysis when AI fails
        const imageInfo = this.getImageInfo(productImage);
        const alt = (imageInfo.alt || '').toLowerCase();
        const src = (productImage.src || '').toLowerCase();

        let score = 5; // Default neutral score
        let reasoning = 'Basic compatibility assessment';

        // Check for color mentions in alt text
        const preferredColors = profile.color_palette?.best_colors || [];
        const colorWords = preferredColors.map(c => c.toLowerCase());

        if (colorWords.some(color => alt.includes(color) || src.includes(color))) {
            score += 2;
            reasoning = 'Product mentions preferred colors';
        }

        // Check for style category keywords
        const styleCategories = profile.style_categories?.map(cat => cat.name.toLowerCase()) || [];
        if (styleCategories.some(style => alt.includes(style) || src.includes(style))) {
            score += 1;
            reasoning = 'Product matches style category preferences';
        }

        // Check for avoid colors
        const avoidColors = profile.color_palette?.avoid_colors || [];
        if (avoidColors.some(color => alt.includes(color.toLowerCase()))) {
            score -= 2;
            reasoning = 'Product contains colors to avoid';
        }

        return {
            score: Math.min(10, Math.max(1, score)),
            reasoning: reasoning,
            confidence: 0.5,
            method: 'fallback_analysis'
        };
    }

    generateProductCacheKey(productImage, profile) {
        // Create unique key for caching based on image and profile
        const imageSrc = productImage.src || '';
        const imageAlt = productImage.alt || '';
        const profileHash = profile.generated_at || Date.now();

        // Simple hash function for cache key
        const text = `${imageSrc}|${imageAlt}|${profileHash}`;
        let hash = 0;
        for (let i = 0; i < text.length; i++) {
            const char = text.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return `product_${Math.abs(hash)}`;
    }

    // Step 5.1: Batch Processing for Multiple Products
    async analyzeMultipleProducts(productImages, options = {}) {
        console.log(`üîÑ Starting batch analysis of ${productImages.length} products`);

        const batchSize = options.batchSize || 8;
        const results = [];

        // Process in batches to avoid overwhelming the API
        for (let i = 0; i < productImages.length; i += batchSize) {
            const batch = productImages.slice(i, i + batchSize);
            console.log(`üì¶ Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(productImages.length/batchSize)}`);

            const batchPromises = batch.map(async (img, index) => {
                const globalIndex = i + index;
                try {
                    const analysis = await this.analyzeProduct(img);
                    return {
                        element: img,
                        analysis: analysis,
                        index: globalIndex
                    };
                } catch (error) {
                    console.error(`Analysis failed for product ${globalIndex}:`, error);
                    return {
                        element: img,
                        analysis: {
                            score: 5,
                            reasoning: 'Analysis failed',
                            confidence: 0,
                            method: 'error'
                        },
                        index: globalIndex
                    };
                }
            });

            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);

            // Small delay between batches to be respectful to API
            if (i + batchSize < productImages.length) {
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }

        console.log(`‚úÖ Batch analysis complete: ${results.length} products analyzed`);
        this.logAnalysisStatistics();

        return results;
    }

    logAnalysisStatistics() {
        const cacheStats = {
            totalAnalyzed: this.analysisStats.totalAnalyzed,
            cacheHits: this.analysisStats.cacheHits,
            apiCalls: this.analysisStats.apiCalls,
            failures: this.analysisStats.failures,
            consecutiveFailures: this.analysisStats.consecutiveFailures,
            circuitBreakerOpen: this.circuitBreakerOpen,
            cacheHitRate: this.analysisStats.totalAnalyzed > 0 ?
                Math.round((this.analysisStats.cacheHits / this.analysisStats.totalAnalyzed) * 100) + '%' : '0%',
            successRate: this.analysisStats.apiCalls > 0 ?
                Math.round(((this.analysisStats.apiCalls - this.analysisStats.failures) / this.analysisStats.apiCalls) * 100) + '%' : '100%',
            averageScore: Math.round(this.analysisStats.averageScore * 10) / 10,
            queueLength: this.analysisQueue.length,
            activeAnalyses: this.activeAnalyses,
            cacheSize: this.analysisCache.size,
            processedImages: this.processedImages.size
        };

        console.log('üìä Analysis Statistics:', cacheStats);
        return cacheStats;
    }

    // Enhanced cache debugging
    debugCache() {
        console.log('üóÉÔ∏è Cache Debug Information:');
        console.log('Cache size:', this.analysisCache.size);
        console.log('Processed images:', this.processedImages.size);

        if (this.analysisCache.size > 0) {
            console.log('Cache contents (first 5 entries):');
            let count = 0;
            for (const [key, value] of this.analysisCache.entries()) {
                if (count >= 5) break;
                console.log(`  ${count + 1}. Score: ${value.score}/10, Method: ${value.method}, Confidence: ${Math.round(value.confidence * 100)}%`);
                console.log(`     Cache key: ${key.substring(0, 50)}...`);
                count++;
            }
        }

        return {
            cacheSize: this.analysisCache.size,
            processedImages: this.processedImages.size,
            cacheHitRate: this.analysisStats.totalAnalyzed > 0 ?
                Math.round((this.analysisStats.cacheHits / this.analysisStats.totalAnalyzed) * 100) : 0
        };
    }

    // Get cache status for a specific image
    getCacheStatusForImage(img) {
        const imgKey = this.getImageKey(img);
        const cacheKey = this.generateProductCacheKey(img, this.userStyleProfile || {});

        const status = {
            imgKey: imgKey,
            cacheKey: cacheKey.substring(0, 50) + '...',
            inCache: this.analysisCache.has(cacheKey),
            processed: this.processedImages.has(imgKey),
            detected: img.dataset.aiStyleDetected === 'true'
        };

        if (status.inCache) {
            const cached = this.analysisCache.get(cacheKey);
            status.cachedScore = cached.score;
            status.cachedMethod = cached.method;
        }

        console.log('üîç Cache status for image:', status);
        return status;
    }

    // Clear analysis cache (useful for testing)
    clearAnalysisCache() {
        this.analysisCache.clear();
        this.analysisStats = {
            totalAnalyzed: 0,
            cacheHits: 0,
            apiCalls: 0,
            averageScore: 0
        };
        console.log('üßπ Analysis cache cleared');
    }

    initializeForPageType() {
        switch (this.pageType) {
            case 'product':
                console.log('üõçÔ∏è Initializing for product page');
                this.initializeProductPage();
                break;
            case 'category':
            case 'search':
                console.log('üìã Initializing for listing page');
                this.initializeListingPage();
                break;
            default:
                console.log('üè† Initializing for general page');
                this.initializeGeneralPage();
        }
    }
    
    initializeProductPage() {
        // Product page specific initialization
        console.log('üõçÔ∏è Setting up product page features...');
        this.testSelectors();
        
        // Step 4.2: Product Image Detection
        setTimeout(async () => {
            await this.detectProductImages();
        }, 1000); // Wait for dynamic content to load
    }
    
    initializeListingPage() {
        // Category/search page specific initialization
        console.log('üìã Setting up listing page features...');
        this.testSelectors();
        
        // Step 4.2: Product Image Detection for listings
        setTimeout(async () => {
            await this.detectProductImages();
        }, 1500); // Wait longer for grid loading
    }
    
    initializeGeneralPage() {
        // General page initialization
        console.log('üè† Setting up general page features...');
        this.testSelectors();
        
        // Still try to detect products on other pages
        setTimeout(async () => {
            await this.detectProductImages();
        }, 1000);
    }
    
    testSelectors() {
        if (!this.currentSite.selectors) return;
        
        console.log(`üîç Testing selectors for ${this.currentSite.name}:`);
        
        // Test product images
        let foundElements = 0;
        for (const selector of this.currentSite.selectors.productImages) {
            const elements = document.querySelectorAll(selector);
            if (elements.length > 0) {
                console.log(`  ‚úÖ Product images: ${selector} (${elements.length} found)`);
                foundElements += elements.length;
            }
        }
        
        // Test product cards
        for (const selector of this.currentSite.selectors.productCards) {
            const elements = document.querySelectorAll(selector);
            if (elements.length > 0) {
                console.log(`  ‚úÖ Product cards: ${selector} (${elements.length} found)`);
                foundElements += elements.length;
            }
        }
        
        // Test product links
        for (const selector of this.currentSite.selectors.productLinks) {
            const elements = document.querySelectorAll(selector);
            if (elements.length > 0) {
                console.log(`  ‚úÖ Product links: ${selector} (${elements.length} found)`);
                foundElements += elements.length;
            }
        }
        
        if (foundElements === 0) {
            console.log(`  ‚ö†Ô∏è No elements found with current selectors for ${this.currentSite.name}`);
            console.log(`  üí° Page may still be loading or selectors may need updating`);
        } else {
            console.log(`  üìä Total elements found: ${foundElements}`);
        }
    }
    
    // Step 4.2: Product Image Detection System
    async detectProductImages() {
        console.log('üîç Starting product image detection...');

        // Clear any existing detection
        this.clearProductDetection();

        const detectedImages = [];
        const rejectedImages = [];

        // Get all selectors for current site
        if (!this.currentSite.selectors) {
            console.log('‚ùå No selectors defined for this site');
            return;
        }

        // Detect product images using site-specific selectors
        const candidateImages = this.findCandidateImages();

        console.log(`üì∏ Found ${candidateImages.length} candidate images (before visibility filtering)`);

        // Show loading animation while analysis is running
        this.showLoadingAnimation();

        // Filter and validate images (now with controlled batching for AI analysis)
        console.log('üß† Starting AI-powered image analysis with controlled concurrency...');

        // Process images in smaller batches to avoid overwhelming the AI APIs
        const batchSize = 12; // Process 12 images at a time for faster detection
        const allResults = [];

        for (let batchStart = 0; batchStart < candidateImages.length; batchStart += batchSize) {
            const batch = candidateImages.slice(batchStart, batchStart + batchSize);
            console.log(`üì¶ Processing image batch ${Math.floor(batchStart/batchSize) + 1}/${Math.ceil(candidateImages.length/batchSize)}`);

            const imageProcessingPromises = batch.map(async (img, i) => {
                const globalIndex = batchStart + i;
            const imageInfo = this.getImageInfo(img);

            console.log(`\nüì∏ Image ${i + 1}/${candidateImages.length}:`);
            console.log(`  Alt: "${imageInfo.alt}"`);
            console.log(`  Src: ${imageInfo.srcShort}`);
            console.log(`  Size: ${imageInfo.width}x${imageInfo.height}`);

            // Check visibility first (faster than AI analysis)
            const visibilityCheck = this.isImageVisible(img);
            if (!visibilityCheck.isVisible) {
                console.log(`  ‚ùå REJECTED (visibility): ${visibilityCheck.reason}`);
                return {
                    type: 'rejected',
                    data: {
                        element: img,
                        quality: { isValid: false },
                        isClothing: { isClothing: false },
                        reason: visibilityCheck.reason,
                        method: 'visibility_check',
                        imageInfo: imageInfo
                    }
                };
            }
            console.log(`  ‚úÖ Visibility passed (${visibilityCheck.reason})`);

            const quality = this.checkImageQuality(img);
            if (!quality.isValid) {
                console.log(`  ‚ùå REJECTED (quality_check): ${quality.reason}`);
                return {
                    type: 'rejected',
                    data: {
                        element: img,
                        quality: quality,
                        isClothing: { isClothing: false },
                        reason: quality.reason,
                        method: 'quality_check',
                        imageInfo: imageInfo
                    }
                };
            }

            console.log(`  ‚úÖ Quality passed`);

            const isClothing = await this.isClothingImage(img);

            if (isClothing.isClothing) {
                console.log(`  ‚úÖ DETECTED (${isClothing.method}): ${isClothing.reasoning}`);
                if (isClothing.confidence) {
                    console.log(`  üìä Confidence: ${Math.round(isClothing.confidence * 100)}%`);
                }

                return {
                    type: 'detected',
                    data: {
                        element: img,
                        quality: quality,
                        reasoning: isClothing.reasoning,
                        method: isClothing.method,
                        confidence: isClothing.confidence,
                        source: this.getImageSource(img),
                        imageInfo: imageInfo
                    }
                };
            } else {
                console.log(`  ‚ùå REJECTED (${isClothing.method}): ${isClothing.reasoning}`);
                if (isClothing.confidence) {
                    console.log(`  üìä Confidence: ${Math.round(isClothing.confidence * 100)}%`);
                }

                return {
                    type: 'rejected',
                    data: {
                        element: img,
                        quality: quality,
                        isClothing: isClothing,
                        reason: isClothing.reasoning,
                        method: isClothing.method,
                        confidence: isClothing.confidence,
                        imageInfo: imageInfo
                    }
                };
            }
        });

        // Wait for all image processing to complete
        console.log('‚è≥ Processing all images concurrently...');
        const results = await Promise.all(imageProcessingPromises);

        // Sort results into detected and rejected arrays
        results.forEach(result => {
            if (result.type === 'detected') {
                detectedImages.push(result.data);
            } else {
                rejectedImages.push(result.data);
            }
        });

        }

        // Hide loading animation
        this.hideLoadingAnimation();

        // Step 5.1: Concurrent style analysis for all detected images
        if (detectedImages.length > 0 && this.userStyleProfile) {
            console.log('üé® Starting concurrent style analysis for all detected products...');

            // Show loading animation for style analysis
            this.showLoadingAnimation('Analyzing style compatibility...');

            // Analyze ALL detected images concurrently
            const allElements = detectedImages.map(item => item.element);
            console.log(`üìä Analyzing ${allElements.length} products concurrently...`);

            try {
                const analysisResults = await this.analyzeMultipleProducts(allElements);

                // Mark all as processed and combine results
                analysisResults.forEach(result => {
                    const imgKey = this.getImageKey(result.element);
                    this.processedImages.add(imgKey);

                    const detectionItem = detectedImages.find(item => item.element === result.element);
                    if (detectionItem) {
                        detectionItem.styleAnalysis = result.analysis;
                    }
                });

                console.log(`‚úÖ Completed style analysis for ${analysisResults.length} products`);
            } catch (error) {
                console.error('‚ùå Error during style analysis:', error);
            }

            // Hide loading animation
            this.hideLoadingAnimation();
        } else if (detectedImages.length > 0) {
            console.log('‚ö†Ô∏è No style profile available - skipping compatibility analysis');
        }

        // Add visual indicators (will show scores for analyzed images, basic borders for others)
        this.addVisualIndicators(detectedImages, rejectedImages);

        // Log results including analysis
        this.logDetectionResults(detectedImages, rejectedImages);

        // Store for later use
        this.detectedProducts = detectedImages;

        return detectedImages;
    }

    // Optimized method to only process new, unanalyzed images during scroll (now concurrent)
    async detectNewProductImages() {
        console.log('üîç Checking for new product images (optimized + concurrent)...');

        // Get only unprocessed candidate images
        const allCandidates = this.findCandidateImages();
        const newCandidates = allCandidates.filter(img => !img.dataset.aiStyleDetected);

        if (newCandidates.length === 0) {
            console.log('‚úÖ No new images to process');
            return [];
        }

        console.log(`üì∏ Found ${newCandidates.length} new candidate images to analyze`);

        // Show loading animation for new images
        this.showLoadingAnimation(`Analyzing ${newCandidates.length} new products...`);

        // Process all new images concurrently
        const imageProcessingPromises = newCandidates.map(async (img, i) => {
            const imageInfo = this.getImageInfo(img);

            console.log(`\nüì∏ New Image ${i + 1}/${newCandidates.length}:`);
            console.log(`  Alt: "${imageInfo.alt}"`);
            console.log(`  Src: ${imageInfo.srcShort}`);
            console.log(`  Size: ${imageInfo.width}x${imageInfo.height}`);

            // Check visibility first (faster than AI analysis)
            const visibilityCheck = this.isImageVisible(img);
            if (!visibilityCheck.isVisible) {
                console.log(`  ‚ùå REJECTED (visibility): ${visibilityCheck.reason}`);
                // Mark as processed even if rejected to avoid reprocessing
                img.dataset.aiStyleDetected = 'false';
                return null;
            }
            console.log(`  ‚úÖ Visibility passed (${visibilityCheck.reason})`);

            const quality = this.checkImageQuality(img);
            if (!quality.isValid) {
                console.log(`  ‚ùå REJECTED (quality_check): ${quality.reason}`);
                // Mark as processed even if rejected to avoid reprocessing
                img.dataset.aiStyleDetected = 'false';
                return null;
            }

            console.log(`  ‚úÖ Quality passed`);

            const isClothing = await this.isClothingImage(img);

            if (isClothing.isClothing) {
                console.log(`  ‚úÖ DETECTED (${isClothing.method}): ${isClothing.reasoning}`);
                if (isClothing.confidence) {
                    console.log(`  üìä Confidence: ${Math.round(isClothing.confidence * 100)}%`);
                }

                return {
                    element: img,
                    quality: quality,
                    reasoning: isClothing.reasoning,
                    method: isClothing.method,
                    confidence: isClothing.confidence,
                    source: this.getImageSource(img),
                    imageInfo: imageInfo
                };
            } else {
                console.log(`  ‚ùå REJECTED (${isClothing.method}): ${isClothing.reasoning}`);
                if (isClothing.confidence) {
                    console.log(`  üìä Confidence: ${Math.round(isClothing.confidence * 100)}%`);
                }
                // Mark as processed even if rejected to avoid reprocessing
                img.dataset.aiStyleDetected = 'false';
                return null;
            }
        });

        // Wait for all processing to complete
        console.log('‚è≥ Processing new images concurrently...');
        const results = await Promise.all(imageProcessingPromises);

        // Filter out null results and get detected images
        const detectedImages = results.filter(result => result !== null);

        // Hide loading animation
        this.hideLoadingAnimation();

        // Add visual indicators and style analysis for new detected images
        if (detectedImages.length > 0) {
            console.log(`\nüéØ Processing ${detectedImages.length} newly detected product images...`);

            // Style analysis for new images if we have a user profile
            if (this.userStyleProfile) {
                console.log('üé® Starting style analysis for new products...');
                this.showLoadingAnimation('Analyzing style compatibility...');

                try {
                    const allElements = detectedImages.map(item => item.element);
                    const analysisResults = await this.analyzeMultipleProducts(allElements);

                    // Combine style analysis results
                    analysisResults.forEach(result => {
                        const imgKey = this.getImageKey(result.element);
                        this.processedImages.add(imgKey);

                        const detectionItem = detectedImages.find(item => item.element === result.element);
                        if (detectionItem) {
                            detectionItem.styleAnalysis = result.analysis;
                        }
                    });

                    console.log(`‚úÖ Completed style analysis for ${analysisResults.length} new products`);
                } catch (error) {
                    console.error('‚ùå Error during style analysis:', error);
                }

                this.hideLoadingAnimation();
            }

            // Get current image count to continue indexing from where we left off
            const existingDetectedImages = document.querySelectorAll('[data-ai-style-detected="true"]');
            const startIndex = existingDetectedImages.length;

            // Add visual indicators starting from the next available index
            this.addVisualIndicators(detectedImages, [], startIndex);

            // Update the stored detected products
            if (!this.detectedProducts) {
                this.detectedProducts = [];
            }
            this.detectedProducts.push(...detectedImages);
        }

        console.log(`‚úÖ New image detection complete! Found ${detectedImages.length} new products.`);
        return detectedImages;
    }

    findCandidateImages() {
        const candidates = new Set();
        let selectorStats = {
            siteSpecific: 0,
            productCards: 0,
            general: 0,
            universal: 0
        };
        
        console.log(`üîç Looking for images on ${this.currentSite.name}...`);
        
        // Use site-specific selectors
        console.log('  üìã Testing site-specific selectors:');
        for (const selector of this.currentSite.selectors.productImages) {
            try {
                const images = document.querySelectorAll(selector);
                if (images.length > 0) {
                    console.log(`    ‚úÖ ${selector}: ${images.length} images`);
                    images.forEach(img => candidates.add(img));
                    selectorStats.siteSpecific += images.length;
                } else {
                    console.log(`    ‚ùå ${selector}: 0 images`);
                }
            } catch (e) {
                console.log(`    ‚ö†Ô∏è ${selector}: invalid selector`);
            }
        }
        
        // Also check images within product cards
        console.log('  üé¥ Testing product card selectors:');
        for (const selector of this.currentSite.selectors.productCards) {
            try {
                const cards = document.querySelectorAll(selector);
                console.log(`    üì¶ ${selector}: ${cards.length} cards found`);
                cards.forEach(card => {
                    const images = card.querySelectorAll('img');
                    images.forEach(img => candidates.add(img));
                    selectorStats.productCards += images.length;
                });
            } catch (e) {
                console.log(`    ‚ö†Ô∏è ${selector}: invalid selector`);
            }
        }
        
        // Fallback: general product image detection
        console.log('  üîÑ Testing general selectors:');
        const generalSelectors = [
            'img[src*="product"]',
            'img[alt*="product"]',
            'img[data-src*="product"]',
            'img[class*="product"]',
            'img[id*="product"]',
            '.product img',
            '.item img',
            '.card img'
        ];
        
        for (const selector of generalSelectors) {
            try {
                const images = document.querySelectorAll(selector);
                if (images.length > 0) {
                    console.log(`    ‚úÖ ${selector}: ${images.length} images`);
                    images.forEach(img => candidates.add(img));
                    selectorStats.general += images.length;
                }
            } catch (e) {
                // Skip invalid selectors
            }
        }
        
        // Universal fallback: just get ALL images and filter later
        console.log('  üåê Universal fallback:');
        const allImages = document.querySelectorAll('img');
        console.log(`    üì∏ Found ${allImages.length} total images on page`);
        
        // If we found very few images with specific selectors, include more from universal set
        if (candidates.size < 5 && allImages.length > 0) {
            console.log('    üí° Adding more images from universal set...');
            allImages.forEach(img => {
                // Basic filtering to avoid obvious non-product images
                const src = (img.src || '').toLowerCase();
                const alt = (img.alt || '').toLowerCase();
                const className = (img.className || '').toLowerCase();
                
                // Skip obvious navigation/ui elements
                if (src.includes('icon') || src.includes('logo') || src.includes('sprite') ||
                    alt.includes('logo') || className.includes('icon') || className.includes('logo')) {
                    return;
                }
                
                candidates.add(img);
                selectorStats.universal++;
            });
        }
        
        console.log('  üìä Selector Statistics:', selectorStats);
        console.log(`  üéØ Total unique candidates: ${candidates.size}`);
        
        return Array.from(candidates);
    }
    
    checkImageQuality(img) {
        const rect = img.getBoundingClientRect();
        const naturalWidth = img.naturalWidth || 0;
        const naturalHeight = img.naturalHeight || 0;
        const displayWidth = rect.width;
        const displayHeight = rect.height;
        
        // Minimum size requirements
        const minDisplaySize = 50;
        const minNaturalSize = 100;
        const maxDisplaySize = 2000;
        
        // Check if image is too small
        if (displayWidth < minDisplaySize || displayHeight < minDisplaySize) {
            return {
                isValid: false,
                reason: `Too small (${Math.round(displayWidth)}x${Math.round(displayHeight)})`
            };
        }
        
        // Check if image is unreasonably large (likely banner/hero)
        if (displayWidth > maxDisplaySize || displayHeight > maxDisplaySize) {
            return {
                isValid: false,
                reason: `Too large (${Math.round(displayWidth)}x${Math.round(displayHeight)})`
            };
        }
        
        // Check natural dimensions if available
        if (naturalWidth > 0 && naturalHeight > 0) {
            if (naturalWidth < minNaturalSize || naturalHeight < minNaturalSize) {
                return {
                    isValid: false,
                    reason: `Natural size too small (${naturalWidth}x${naturalHeight})`
                };
            }
        }
        
        // Check aspect ratio (clothing images are typically portrait or square)
        const aspectRatio = displayWidth / displayHeight;
        if (aspectRatio > 3 || aspectRatio < 0.3) {
            return {
                isValid: false,
                reason: `Invalid aspect ratio (${aspectRatio.toFixed(2)})`
            };
        }
        
        // Check if image is visible (basic check)
        if (rect.width === 0 || rect.height === 0) {
            return {
                isValid: false,
                reason: 'Not visible (zero dimensions)'
            };
        }
        
        return {
            isValid: true,
            dimensions: {
                display: { width: displayWidth, height: displayHeight },
                natural: { width: naturalWidth, height: naturalHeight },
                aspectRatio: aspectRatio
            }
        };
    }
    
    isImageVisible(img) {
        const rect = img.getBoundingClientRect();
        const style = window.getComputedStyle(img);
        
        // Check basic CSS visibility
        if (style.display === 'none') {
            return { isVisible: false, reason: 'display: none' };
        }
        
        if (style.visibility === 'hidden') {
            return { isVisible: false, reason: 'visibility: hidden' };
        }
        
        if (parseFloat(style.opacity) === 0) {
            return { isVisible: false, reason: 'opacity: 0' };
        }
        
        // Check if image is outside the viewport
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        
        if (rect.right <= 0 || rect.left >= viewportWidth || 
            rect.bottom <= 0 || rect.top >= viewportHeight) {
            
            // Add detailed debugging for viewport rejection
            const debugInfo = {
                imageRect: {
                    left: rect.left,
                    right: rect.right,
                    top: rect.top,
                    bottom: rect.bottom,
                    width: rect.width,
                    height: rect.height
                },
                viewport: {
                    width: viewportWidth,
                    height: viewportHeight
                },
                checks: {
                    rightLeqZero: rect.right <= 0,
                    leftGeqViewportWidth: rect.left >= viewportWidth,
                    bottomLeqZero: rect.bottom <= 0,
                    topGeqViewportHeight: rect.top >= viewportHeight
                }
            };
            
            console.log('üêõ VIEWPORT DEBUG - Image rejected as outside viewport:', debugInfo);
            console.log('üêõ Image src:', img.src);
            console.log('üêõ Image alt:', img.alt);
            
            return { 
                isVisible: false, 
                reason: 'outside viewport',
                debugInfo: debugInfo
            };
        }
        
        // Check if image is clipped by parent containers (common in carousels)
        let parent = img.parentElement;
        let depth = 0;
        
        while (parent && depth < 5) {
            const parentRect = parent.getBoundingClientRect();
            const parentStyle = window.getComputedStyle(parent);
            
            // Check if parent has overflow hidden and image is outside its bounds
            if (parentStyle.overflow === 'hidden' || parentStyle.overflowX === 'hidden') {
                // Check if image is clipped horizontally (common in image carousels)
                if (rect.left >= parentRect.right || rect.right <= parentRect.left) {
                    return { isVisible: false, reason: 'clipped by parent container' };
                }
                
                // For carousel detection, check if image is significantly outside parent bounds
                const imageCenter = rect.left + rect.width / 2;
                const parentCenter = parentRect.left + parentRect.width / 2;
                const maxDistance = parentRect.width * 0.6; // Allow some tolerance
                
                if (Math.abs(imageCenter - parentCenter) > maxDistance) {
                    return { isVisible: false, reason: 'carousel image not active' };
                }
            }
            
            if (parentStyle.overflow === 'hidden' || parentStyle.overflowY === 'hidden') {
                // Check if image is clipped vertically
                if (rect.top >= parentRect.bottom || rect.bottom <= parentRect.top) {
                    return { isVisible: false, reason: 'clipped by parent container' };
                }
            }
            
            parent = parent.parentElement;
            depth++;
        }
        
        // Check intersection with viewport (more precise than basic bounds check)
        const viewportIntersection = {
            left: Math.max(rect.left, 0),
            top: Math.max(rect.top, 0),
            right: Math.min(rect.right, viewportWidth),
            bottom: Math.min(rect.bottom, viewportHeight)
        };
        
        const intersectionWidth = Math.max(0, viewportIntersection.right - viewportIntersection.left);
        const intersectionHeight = Math.max(0, viewportIntersection.bottom - viewportIntersection.top);
        const intersectionArea = intersectionWidth * intersectionHeight;
        const imageArea = rect.width * rect.height;
        
        // Require at least 25% of the image to be visible (lowered from 50% for sites like H&M)
        const visibilityRatio = imageArea > 0 ? intersectionArea / imageArea : 0;
        if (visibilityRatio < 0.25) {
            // Add detailed debugging for visibility rejection
            const debugInfo = {
                imageRect: {
                    left: Math.round(rect.left),
                    right: Math.round(rect.right),
                    top: Math.round(rect.top),
                    bottom: Math.round(rect.bottom),
                    width: Math.round(rect.width),
                    height: Math.round(rect.height)
                },
                viewport: {
                    width: viewportWidth,
                    height: viewportHeight
                },
                intersection: {
                    left: Math.round(viewportIntersection.left),
                    right: Math.round(viewportIntersection.right),
                    top: Math.round(viewportIntersection.top),
                    bottom: Math.round(viewportIntersection.bottom),
                    width: Math.round(intersectionWidth),
                    height: Math.round(intersectionHeight)
                },
                areas: {
                    imageArea: Math.round(imageArea),
                    intersectionArea: Math.round(intersectionArea),
                    visibilityRatio: Math.round(visibilityRatio * 100) / 100
                }
            };

            console.log('üêõ VISIBILITY DEBUG - Image rejected for low visibility:', debugInfo);
            console.log('üêõ Image src:', img.src);
            console.log('üêõ Image alt:', img.alt);

            return {
                isVisible: false,
                reason: `only ${Math.round(visibilityRatio * 100)}% visible (need 25%+)`,
                debugInfo: debugInfo
            };
        }
        
        return {
            isVisible: true,
            reason: `${Math.round(visibilityRatio * 100)}% visible`,
            visibilityRatio: visibilityRatio
        };
    }
    
    async isClothingImage(img) {
        // Multi-layered detection approach using Chrome's built-in AI
        
        // Layer 1: Quick exclusion checks (fastest, no AI needed)
        const quickExclusion = this.quickExclusionCheck(img);
        if (!quickExclusion.passed) {
            return {
                isClothing: false,
                reasoning: quickExclusion.reason,
                method: 'quick_exclusion'
            };
        }
        
        // Layer 2: AI-powered alt text analysis (fast, uses language model)
        const altTextAnalysis = await this.analyzeAltTextWithAI(img);
        if (altTextAnalysis.confident) {
            return {
                isClothing: altTextAnalysis.isClothing,
                reasoning: altTextAnalysis.reasoning,
                method: 'ai_alt_text'
            };
        }
        
        // Layer 3: Image classification (more expensive, only if needed)
        const imageClassification = await this.classifyImageWithAI(img);
        if (imageClassification.confident) {
            return {
                isClothing: imageClassification.isClothing,
                reasoning: imageClassification.reasoning,
                method: 'ai_image_classification'
            };
        }
        
        // Layer 4: Context analysis fallback
        const contextAnalysis = this.analyzeImageContext(img);
        return {
            isClothing: contextAnalysis.isClothing,
            reasoning: contextAnalysis.reasoning,
            method: 'context_analysis'
        };
    }
    
    quickExclusionCheck(img) {
        const src = (img.src || '').toLowerCase();
        const alt = (img.alt || '').toLowerCase();
        const className = (img.className || '').toLowerCase();

        // Check for obvious UI elements, but be smarter about context
        // Only exclude if these patterns appear in non-clothing contexts

        // Check src and className for UI elements (these are more reliable)
        const uiPatterns = [
            'logo', 'icon', 'sprite', 'arrow', 'close', 'menu', 'nav',
            'header', 'footer', 'sidebar', 'banner', 'advertisement'
        ];

        const srcAndClass = `${src} ${className}`;

        for (const pattern of uiPatterns) {
            if (srcAndClass.includes(pattern)) {
                return {
                    passed: false,
                    reason: `UI element detected: contains '${pattern}' in src/class`
                };
            }
        }

        // Check image dimensions for obvious non-product images
        const rect = img.getBoundingClientRect();
        if (rect.width < 30 || rect.height < 30) {
            return {
                passed: false,
                reason: 'Too small - likely icon or thumbnail'
            };
        }

        return { passed: true };
    }
    
    async analyzeAltTextWithAI(img) {
        // Use Chrome's language model to analyze alt text and context
        const alt = img.alt || '';
        const title = img.title || '';
        const src = img.src || '';
        
        if (!alt && !title) {
            return { confident: false };
        }
        
        try {
            // Check if AI is available
            if (typeof window !== 'undefined' && window.ai) {
                const session = await window.ai.createTextSession({
                    temperature: 0.1, // Low temperature for consistent classification
                    topK: 1
                });
                
                const prompt = `Analyze this image description and determine if it describes clothing, shoes, or fashion accessories.

Image alt text: "${alt}"
Image title: "${title}"
Image URL: "${src.split('/').pop()}"

Respond with ONLY one of these formats:
- "CLOTHING: [item type]" if it's clothing/shoes/accessories
- "NOT_CLOTHING: [reason]" if it's not clothing

Examples:
- "CLOTHING: dress" for a dress
- "CLOTHING: sneakers" for shoes  
- "NOT_CLOTHING: logo" for company logos
- "NOT_CLOTHING: navigation" for UI elements`;

                const response = await session.prompt(prompt);
                session.destroy();
                
                if (response.startsWith('CLOTHING:')) {
                    return {
                        confident: true,
                        isClothing: true,
                        reasoning: `AI classified as clothing: ${response.split(':')[1].trim()}`,
                        confidence: 0.9 // High confidence for explicit AI classification
                    };
                } else if (response.startsWith('NOT_CLOTHING:')) {
                    return {
                        confident: true,
                        isClothing: false,
                        reasoning: `AI classified as non-clothing: ${response.split(':')[1].trim()}`,
                        confidence: 0.9 // High confidence for explicit AI classification
                    };
                }
            }
        } catch (error) {
            console.log('AI alt text analysis failed:', error);
        }
        
        return { confident: false };
    }
    
    async classifyImageWithAI(img) {
        // Use Chrome's built-in image classification if available
        try {
            // Check if image classification API is available
            if (typeof window !== 'undefined' && window.ai && window.ai.createImageClassifier) {
                const classifier = await window.ai.createImageClassifier();
                
                // Create a canvas to extract image data
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas size (smaller for faster processing)
                canvas.width = Math.min(img.naturalWidth || img.width, 224);
                canvas.height = Math.min(img.naturalHeight || img.height, 224);
                
                // Draw image to canvas
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                // Get image data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Classify the image
                const results = await classifier.classify(imageData);
                
                // Look for clothing-related classifications
                const clothingCategories = [
                    'shirt', 'dress', 'pants', 'jeans', 'jacket', 'coat', 'sweater',
                    'shoes', 'sneakers', 'boots', 'hat', 'cap', 'socks', 'underwear',
                    'skirt', 'shorts', 'hoodie', 'vest', 'blazer', 'suit', 'tie',
                    'scarf', 'gloves', 'belt', 'bag', 'purse', 'backpack'
                ];
                
                for (const result of results) {
                    const label = result.label.toLowerCase();
                    const confidence = result.confidence;
                    
                    // High confidence clothing detection
                    if (confidence > 0.7 && clothingCategories.some(cat => label.includes(cat))) {
                        return {
                            confident: true,
                            isClothing: true,
                            reasoning: `AI image classification: ${label}`,
                            confidence: confidence
                        };
                    }
                    
                    // High confidence non-clothing detection
                    if (confidence > 0.8 && !clothingCategories.some(cat => label.includes(cat))) {
                        const nonClothingCategories = ['person', 'face', 'building', 'car', 'animal', 'food'];
                        if (nonClothingCategories.some(cat => label.includes(cat))) {
                            return {
                                confident: true,
                                isClothing: false,
                                reasoning: `AI image classification: ${label}`,
                                confidence: confidence
                            };
                        }
                    }
                }
                
                classifier.destroy();
            }
        } catch (error) {
            console.log('AI image classification failed:', error);
        }
        
        return { confident: false };
    }
    
    analyzeImageContext(img) {
        // Fallback context analysis (improved version of original logic)
        const isInProductArea = this.isInProductArea(img);
        const rect = img.getBoundingClientRect();
        
        // If in a product area and reasonable size, likely clothing
        if (isInProductArea && rect.width > 100 && rect.height > 100) {
            return {
                isClothing: true,
                reasoning: 'Located in product area with appropriate size'
            };
        }
        
        // Check if image is in a grid layout (common for product catalogs)
        const isInGrid = this.isInGridLayout(img);
        if (isInGrid) {
            return {
                isClothing: true,
                reasoning: 'Located in product grid layout'
            };
        }
        
        // Default to including (better to have false positives than miss items)
        return {
            isClothing: true,
            reasoning: 'Default inclusion - no clear exclusion criteria met'
        };
    }
    
    isInGridLayout(img) {
        // Check if the image is part of a grid layout
        let parent = img.parentElement;
        let depth = 0;
        
        while (parent && depth < 5) {
            const style = window.getComputedStyle(parent);
            
            // Check for CSS Grid or Flexbox with multiple items
            if (style.display === 'grid' || 
                (style.display === 'flex' && parent.children.length > 3)) {
                return true;
            }
            
            // Check for common grid class names
            const className = parent.className.toLowerCase();
            if (className.includes('grid') || className.includes('catalog') || 
                className.includes('products') || className.includes('items')) {
                return true;
            }
            
            parent = parent.parentElement;
            depth++;
        }
        
        return false;
    }
    
    getParentClasses(element) {
        const classes = [];
        let parent = element.parentElement;
        let depth = 0;
        
        while (parent && depth < 5) {
            if (parent.className) {
                classes.push(parent.className);
            }
            parent = parent.parentElement;
            depth++;
        }
        
        return classes.join(' ');
    }
    
    isInProductArea(img) {
        const productSelectors = [
            ...this.currentSite.selectors.productCards,
            '.product', '.item', '.card', '.tile', '.grid-item'
        ];
        
        let parent = img.parentElement;
        let depth = 0;
        
        while (parent && depth < 10) {
            for (const selector of productSelectors) {
                try {
                    if (parent.matches(selector)) {
                        return true;
                    }
                } catch (e) {
                    // Skip invalid selectors
                }
            }
            parent = parent.parentElement;
            depth++;
        }
        
        return false;
    }
    
    getImageSource(img) {
        return {
            src: img.src || '',
            dataSrc: img.dataset.src || '',
            alt: img.alt || '',
            title: img.title || ''
        };
    }
    
    getImageInfo(img) {
        const rect = img.getBoundingClientRect();
        const src = img.src || img.dataset.src || '';
        
        // Create a short version of the src for logging
        let srcShort = src;
        if (src.length > 60) {
            const parts = src.split('/');
            srcShort = '.../' + parts[parts.length - 1];
            if (srcShort.length > 60) {
                srcShort = srcShort.substring(0, 57) + '...';
            }
        }
        
        return {
            alt: img.alt || '(no alt text)',
            title: img.title || '(no title)',
            src: src,
            srcShort: srcShort,
            width: Math.round(rect.width),
            height: Math.round(rect.height),
            className: img.className || '(no class)',
            id: img.id || '(no id)'
        };
    }
    
    positionOverlay(overlay, img) {
        // Get the image's position and dimensions
        const rect = img.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
        
        // Calculate absolute position
        const top = rect.top + scrollTop;
        const left = rect.left + scrollLeft;
        const width = rect.width;
        const height = rect.height;
        
        // Position the overlay to exactly cover the image
        overlay.style.position = 'absolute';
        overlay.style.top = `${top}px`;
        overlay.style.left = `${left}px`;
        overlay.style.width = `${width}px`;
        overlay.style.height = `${height}px`;
        
        // Remove the relative positioning properties that were causing issues
        overlay.style.removeProperty('right');
        overlay.style.removeProperty('bottom');
    }

    positionScoreBadge(badge, img) {
        // Get the image's position and dimensions
        const rect = img.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

        // Calculate absolute position for top-right corner of image (smaller badge)
        const top = rect.top + scrollTop + 5; // 5px margin from top
        const left = rect.left + scrollLeft + rect.width - 25; // Position from right edge (smaller offset for 20px badge)

        // Position the badge
        badge.style.position = 'absolute';
        badge.style.top = `${top}px`;
        badge.style.left = `${left}px`;
    }
    
    addVisualIndicators(detectedImages, rejectedImages, startIndex = 0) {
        console.log('üé® Adding visual indicators...');

        // Add green borders and style score overlays to detected clothing images
        detectedImages.forEach((item, localIndex) => {
            const index = startIndex + localIndex;
            const img = item.element;
            const hasStyleAnalysis = item.styleAnalysis;

            // Determine border color based on style score
            let borderColor = '#10b981'; // Default green
            let borderWidth = '3px';
            let glowColor = 'rgba(16, 185, 129, 0.6)';

            if (hasStyleAnalysis) {
                const score = item.styleAnalysis.score;
                if (score >= 8) {
                    borderColor = '#059669'; // Darker green for high scores
                    glowColor = 'rgba(5, 150, 105, 0.8)';
                    borderWidth = '4px';
                } else if (score >= 6) {
                    borderColor = '#10b981'; // Standard green
                    glowColor = 'rgba(16, 185, 129, 0.6)';
                } else if (score >= 4) {
                    borderColor = '#f59e0b'; // Orange for medium scores
                    glowColor = 'rgba(245, 158, 11, 0.6)';
                } else {
                    borderColor = '#ef4444'; // Red for low scores
                    glowColor = 'rgba(239, 68, 68, 0.6)';
                }
            }

            // Create an overlay element that appears around the image
            const overlay = document.createElement('div');
            overlay.className = 'ai-style-detected-overlay';
            overlay.style.cssText = `
                position: absolute;
                pointer-events: none;
                border: ${borderWidth} solid ${borderColor};
                border-radius: 6px;
                box-shadow: 0 0 15px ${glowColor};
                z-index: 10000;
                top: -3px;
                left: -3px;
                right: -3px;
                bottom: -3px;
            `;

            // Position the overlay relative to the image
            this.positionOverlay(overlay, img);

            // Create style score badge if analysis is available
            if (hasStyleAnalysis) {
                const scoreBadge = document.createElement('div');
                scoreBadge.className = 'ai-style-score-badge';

                // Determine badge color based on score
                let badgeColor = '#10b981';
                if (item.styleAnalysis.score >= 8) badgeColor = '#059669';
                else if (item.styleAnalysis.score >= 6) badgeColor = '#10b981';
                else if (item.styleAnalysis.score >= 4) badgeColor = '#f59e0b';
                else badgeColor = '#ef4444';

                scoreBadge.style.cssText = `
                    position: absolute;
                    top: 5px;
                    right: 5px;
                    background: ${badgeColor};
                    color: white;
                    border-radius: 50%;
                    width: 20px;
                    height: 20px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 11px;
                    font-weight: bold;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    z-index: 10001;
                    pointer-events: none;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                `;
                scoreBadge.textContent = `${item.styleAnalysis.score}`;

                // Position the badge relative to the image
                this.positionScoreBadge(scoreBadge, img);
                document.body.appendChild(scoreBadge);

                // Store reference for cleanup
                overlay.dataset.aiStyleScoreBadge = 'true';
                scoreBadge.dataset.aiStyleOverlay = 'score-badge';
                scoreBadge.dataset.aiStyleTargetIndex = index;

                // Update badge position if image moves
                const updateBadgePosition = () => this.positionScoreBadge(scoreBadge, img);
                window.addEventListener('scroll', updateBadgePosition);
                window.addEventListener('resize', updateBadgePosition);
            }

            // Add data attributes for identification and cleanup
            img.dataset.aiStyleDetected = 'true';
            img.dataset.aiStyleIndex = index;
            overlay.dataset.aiStyleOverlay = 'detected';
            overlay.dataset.aiStyleTargetIndex = index;

            // Enhanced hover tooltip with style analysis
            let tooltipText = `AI Style Filter: Detected clothing image
Method: ${item.method}
Reason: ${item.reasoning}
Size: ${Math.round(item.quality.dimensions.display.width)}x${Math.round(item.quality.dimensions.display.height)}`;

            if (hasStyleAnalysis) {
                tooltipText += `
Style Score: ${item.styleAnalysis.score}/10 (${Math.round(item.styleAnalysis.confidence * 100)}% confidence)
Analysis: ${item.styleAnalysis.reasoning}`;
            }

            img.title = tooltipText;

            // Insert the overlay into the document
            document.body.appendChild(overlay);

            // Update overlay position if image moves (for responsive layouts)
            const updatePosition = () => this.positionOverlay(overlay, img);
            window.addEventListener('scroll', updatePosition);
            window.addEventListener('resize', updatePosition);
        });
        
        // Add red borders to rejected images (for debugging, only if enabled)
        if (this.debugMode) {
            rejectedImages.forEach((item, index) => {
                const img = item.element;
                
                // Create an overlay element for rejected images
                const overlay = document.createElement('div');
                overlay.className = 'ai-style-rejected-overlay';
                overlay.style.cssText = `
                    position: absolute;
                    pointer-events: none;
                    border: 2px solid #ef4444;
                    border-radius: 4px;
                    box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
                    z-index: 9999;
                    top: -2px;
                    left: -2px;
                    right: -2px;
                    bottom: -2px;
                `;
                
                // Position the overlay relative to the image
                this.positionOverlay(overlay, img);
                
                // Add data attributes for identification
                img.dataset.aiStyleRejected = 'true';
                img.dataset.aiStyleRejectIndex = index;
                overlay.dataset.aiStyleOverlay = 'rejected';
                overlay.dataset.aiStyleTargetIndex = index;
                
                // Add hover tooltip
                img.title = `AI Style Filter: Rejected (${item.method})
Reason: ${item.reason}`;
                
                // Insert the overlay into the document
                document.body.appendChild(overlay);
                
                // Update overlay position if image moves
                const updatePosition = () => this.positionOverlay(overlay, img);
                window.addEventListener('scroll', updatePosition);
                window.addEventListener('resize', updatePosition);
            });
        }
    }
    
    clearProductDetection() {
        // Remove overlay elements (including score badges)
        const overlays = document.querySelectorAll('[data-ai-style-overlay]');
        overlays.forEach(overlay => {
            overlay.remove();
        });
        
        // Clear image data attributes and styles
        const detectedImages = document.querySelectorAll('[data-ai-style-detected]');
        detectedImages.forEach(img => {
            delete img.dataset.aiStyleDetected;
            delete img.dataset.aiStyleIndex;
            if (img.title && img.title.includes('AI Style Filter')) {
                img.title = '';
            }
        });
        
        const rejectedImages = document.querySelectorAll('[data-ai-style-rejected]');
        rejectedImages.forEach(img => {
            delete img.dataset.aiStyleRejected;
            delete img.dataset.aiStyleRejectIndex;
            if (img.title && img.title.includes('AI Style Filter')) {
                img.title = '';
            }
        });
        
        // Remove any old style-based indicators (fallback for legacy code)
        const styledImages = document.querySelectorAll('img[style*="box-shadow"]');
        styledImages.forEach(img => {
            if (img.style.boxShadow && img.style.boxShadow.includes('rgb(16, 185, 129)')) {
                img.style.boxShadow = '';
                img.style.borderRadius = '';
                img.style.position = '';
                img.style.zIndex = '';
            }
        });
    }

    // Loading animation methods
    showLoadingAnimation(message = 'AI Stylist is analyzing products...') {
        // Remove any existing loading indicator
        this.hideLoadingAnimation();

        // Create loading overlay
        const loadingOverlay = document.createElement('div');
        loadingOverlay.id = 'ai-style-loading-overlay';
        loadingOverlay.setAttribute('data-ai-style-overlay', 'true');

        loadingOverlay.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            z-index: 999999;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            gap: 12px;
            max-width: 280px;
            animation: slideInFade 0.3s ease-out;
        `;

        // Add animation keyframes if not already added
        if (!document.querySelector('#ai-style-loading-keyframes')) {
            const style = document.createElement('style');
            style.id = 'ai-style-loading-keyframes';
            style.textContent = `
                @keyframes slideInFade {
                    from {
                        opacity: 0;
                        transform: translateX(100px);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(0);
                    }
                }
                @keyframes spin {
                    from { transform: rotate(0deg); }
                    to { transform: rotate(360deg); }
                }
                .ai-style-spinner {
                    width: 18px;
                    height: 18px;
                    border: 2px solid rgba(255,255,255,0.3);
                    border-radius: 50%;
                    border-top-color: white;
                    animation: spin 1s linear infinite;
                    flex-shrink: 0;
                }
            `;
            document.head.appendChild(style);
        }

        // Add spinner
        const spinner = document.createElement('div');
        spinner.className = 'ai-style-spinner';

        // Add message
        const messageElement = document.createElement('span');
        messageElement.textContent = message;

        loadingOverlay.appendChild(spinner);
        loadingOverlay.appendChild(messageElement);

        document.body.appendChild(loadingOverlay);

        console.log('üì° Loading animation shown:', message);
    }

    hideLoadingAnimation() {
        const loadingOverlay = document.getElementById('ai-style-loading-overlay');
        if (loadingOverlay) {
            loadingOverlay.style.animation = 'slideInFade 0.3s ease-out reverse';
            setTimeout(() => {
                if (loadingOverlay.parentNode) {
                    loadingOverlay.remove();
                }
            }, 300);
            console.log('üì° Loading animation hidden');
        }
    }

    logDetectionResults(detectedImages, rejectedImages) {
        console.log('üìä Product Detection Results:');
        console.log(`  ‚úÖ Detected clothing images: ${detectedImages.length}`);
        console.log(`  ‚ùå Rejected images: ${rejectedImages.length}`);

        // Show rejection reason breakdown
        const rejectionReasons = {};
        rejectedImages.forEach(item => {
            rejectionReasons[item.method] = (rejectionReasons[item.method] || 0) + 1;
        });
        if (Object.keys(rejectionReasons).length > 0) {
            console.log('  üìâ Rejection breakdown:', rejectionReasons);
        }

        // Style analysis summary
        const analyzedItems = detectedImages.filter(item => item.styleAnalysis);
        if (analyzedItems.length > 0) {
            const avgScore = analyzedItems.reduce((sum, item) => sum + item.styleAnalysis.score, 0) / analyzedItems.length;
            const scoreDistribution = {
                high: analyzedItems.filter(item => item.styleAnalysis.score >= 8).length,
                medium: analyzedItems.filter(item => item.styleAnalysis.score >= 6 && item.styleAnalysis.score < 8).length,
                low: analyzedItems.filter(item => item.styleAnalysis.score < 6).length
            };

            console.log('üé® Style Analysis Summary:');
            console.log(`  üìà Analyzed products: ${analyzedItems.length}/${detectedImages.length}`);
            console.log(`  ‚≠ê Average score: ${Math.round(avgScore * 10) / 10}/10`);
            console.log(`  üìä Score distribution: High(8-10): ${scoreDistribution.high}, Medium(6-7): ${scoreDistribution.medium}, Low(1-5): ${scoreDistribution.low}`);
        }

        // Summary of detected images
        if (detectedImages.length > 0) {
            console.log('\n‚úÖ DETECTED IMAGES SUMMARY:');
            detectedImages.forEach((item, index) => {
                const info = item.imageInfo;
                const conf = item.confidence ? ` (${Math.round(item.confidence * 100)}%)` : '';
                const styleInfo = item.styleAnalysis ? ` | Style: ${item.styleAnalysis.score}/10` : '';
                console.log(`  ${index + 1}. "${info.alt}" - [${item.method}${conf}]${styleInfo} ${item.reasoning}`);
                console.log(`     Size: ${info.width}x${info.height}, Src: ${info.srcShort}`);
                if (item.styleAnalysis) {
                    console.log(`     üé® Style Analysis: ${item.styleAnalysis.reasoning}`);
                }
            });
            
            // Show method statistics
            const methodStats = {};
            detectedImages.forEach(item => {
                methodStats[item.method] = (methodStats[item.method] || 0) + 1;
            });
            console.log('\nüìä Detection methods used:', methodStats);
        }
        
        // Summary of rejected images
        if (rejectedImages.length > 0) {
            console.log(`\n‚ùå REJECTED IMAGES SUMMARY (showing first 10 of ${rejectedImages.length}):`);
            rejectedImages.slice(0, 10).forEach((item, index) => {
                const info = item.imageInfo;
                const conf = item.confidence ? ` (${Math.round(item.confidence * 100)}%)` : '';
                console.log(`  ${index + 1}. "${info.alt}" - [${item.method}${conf}] ${item.reason}`);
                console.log(`     Size: ${info.width}x${info.height}, Src: ${info.srcShort}`);
            });
            
            if (rejectedImages.length > 10) {
                console.log(`     ... and ${rejectedImages.length - 10} more rejected images`);
            }
        }
        
        // Store results for background script
        this.lastDetectionResults = {
            detected: detectedImages.length,
            rejected: rejectedImages.length,
            timestamp: Date.now(),
            pageType: this.pageType,
            site: this.currentSite.name
        };
    }
    
    // Helper method to enable debug mode
    enableDebugMode() {
        this.debugMode = true;
        console.log('üêõ Debug mode enabled - rejected images will be highlighted');
    }
    
    // Helper method to re-run detection
    async redetectProducts() {
        console.log('üîÑ Re-running product detection...');
        return await this.detectProductImages();
    }
    
    // Method to get detection stats
    getDetectionStats() {
        return this.lastDetectionResults || null;
    }
    
    // Debug method to analyze a specific image's visibility
    debugImageVisibility(img) {
        console.log('üîç DETAILED IMAGE VISIBILITY DEBUG');
        console.log('üì∏ Image:', img);
        console.log('üîó Src:', img.src);
        console.log('üìù Alt:', img.alt);
        console.log('üè∑Ô∏è Class:', img.className);
        
        const rect = img.getBoundingClientRect();
        const style = window.getComputedStyle(img);
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        
        console.log('üìê Bounding Rect:', {
            left: rect.left,
            right: rect.right,
            top: rect.top,
            bottom: rect.bottom,
            width: rect.width,
            height: rect.height
        });
        
        console.log('üñ•Ô∏è Viewport:', {
            width: viewportWidth,
            height: viewportHeight
        });
        
        console.log('üé® Computed Style:', {
            display: style.display,
            visibility: style.visibility,
            opacity: style.opacity,
            position: style.position,
            transform: style.transform
        });
        
        // Check each visibility condition
        console.log('‚úÖ Visibility Checks:');
        console.log('  Display !== none:', style.display !== 'none');
        console.log('  Visibility !== hidden:', style.visibility !== 'hidden');
        console.log('  Opacity > 0:', parseFloat(style.opacity) > 0);
        console.log('  Right > 0:', rect.right > 0);
        console.log('  Left < viewport width:', rect.left < viewportWidth);
        console.log('  Bottom > 0:', rect.bottom > 0);
        console.log('  Top < viewport height:', rect.top < viewportHeight);
        
        // Check parent containers
        console.log('üì¶ Parent Container Analysis:');
        let parent = img.parentElement;
        let depth = 0;
        while (parent && depth < 5) {
            const parentRect = parent.getBoundingClientRect();
            const parentStyle = window.getComputedStyle(parent);
            
            console.log(`  Level ${depth + 1}:`, {
                tagName: parent.tagName,
                className: parent.className,
                overflow: parentStyle.overflow,
                overflowX: parentStyle.overflowX,
                overflowY: parentStyle.overflowY,
                rect: {
                    left: parentRect.left,
                    right: parentRect.right,
                    top: parentRect.top,
                    bottom: parentRect.bottom
                }
            });
            
            parent = parent.parentElement;
            depth++;
        }
        
        // Run actual visibility check
        const result = this.isImageVisible(img);
        console.log('üéØ Final Result:', result);
        
        return result;
    }

    // Testing and Debug Methods for Step 5.1

    // Test analysis on a specific product manually
    async testProductAnalysis(imageElement) {
        if (!imageElement || imageElement.tagName !== 'IMG') {
            console.error('Please provide a valid image element');
            return null;
        }

        console.log('üß™ Testing product analysis on specific image...');
        console.log('üì∏ Image:', imageElement.src);
        console.log('üìù Alt text:', imageElement.alt);

        const analysis = await this.analyzeProduct(imageElement);
        console.log('‚úÖ Analysis result:', analysis);

        return analysis;
    }

    // Debug method to analyze visibility issues on H&M and similar sites
    debugVisibilityIssues() {
        console.log('üêõ === VISIBILITY DEBUG ANALYSIS ===');

        const candidates = this.findCandidateImages();
        console.log(`üì∏ Found ${candidates.length} candidate images total`);

        const visibilityResults = {
            passed: [],
            failed: []
        };

        candidates.forEach((img, index) => {
            const result = this.isImageVisible(img);
            const imageInfo = {
                index: index + 1,
                src: img.src?.substring(0, 100) + '...' || 'no src',
                alt: img.alt || 'no alt',
                width: Math.round(img.getBoundingClientRect().width),
                height: Math.round(img.getBoundingClientRect().height),
                result: result
            };

            if (result.isVisible) {
                visibilityResults.passed.push(imageInfo);
            } else {
                visibilityResults.failed.push(imageInfo);
            }

            console.log(`Image ${index + 1}: ${result.isVisible ? '‚úÖ' : '‚ùå'} ${result.reason}`);
            console.log(`  üìê Size: ${imageInfo.width}x${imageInfo.height}`);
            console.log(`  üîó Src: ${imageInfo.src}`);
            if (result.debugInfo) {
                console.log(`  üêõ Debug:`, result.debugInfo);
            }
        });

        console.log(`\nüìä SUMMARY:`);
        console.log(`‚úÖ Passed visibility check: ${visibilityResults.passed.length}`);
        console.log(`‚ùå Failed visibility check: ${visibilityResults.failed.length}`);

        // Show common failure reasons
        const failureReasons = {};
        visibilityResults.failed.forEach(item => {
            const reason = item.result.reason;
            failureReasons[reason] = (failureReasons[reason] || 0) + 1;
        });

        console.log(`\nüîç Failure reasons:`);
        Object.entries(failureReasons).forEach(([reason, count]) => {
            console.log(`  ${reason}: ${count} images`);
        });

        console.log('üêõ === END VISIBILITY DEBUG ===\n');

        return {
            total: candidates.length,
            passed: visibilityResults.passed.length,
            failed: visibilityResults.failed.length,
            failureReasons: failureReasons,
            details: visibilityResults
        };
    }

    // Force re-analysis of all detected products
    async reAnalyzeAllProducts() {
        if (!this.detectedProducts || this.detectedProducts.length === 0) {
            console.log('‚ö†Ô∏è No detected products to re-analyze');
            return;
        }

        console.log('üîÑ Re-analyzing all detected products...');

        // Clear cache to force fresh analysis
        this.clearAnalysisCache();

        // Re-analyze all products
        const productElements = this.detectedProducts.map(item => item.element);
        const results = await this.analyzeMultipleProducts(productElements);

        // Update the detected products with new analysis
        this.detectedProducts.forEach((detectionItem, index) => {
            const analysisItem = results.find(result => result.element === detectionItem.element);
            if (analysisItem) {
                detectionItem.styleAnalysis = analysisItem.analysis;
            }
        });

        // Clear and re-add visual indicators
        this.clearProductDetection();
        this.addVisualIndicators(this.detectedProducts, []);

        console.log('‚úÖ Re-analysis complete!');
        this.logAnalysisStatistics();

        return results;
    }

    // Test specific analysis prompt
    async testAnalysisPrompt(productImage, customProfile = null) {
        const profile = customProfile || this.userStyleProfile;
        if (!profile) {
            console.error('No style profile available for testing');
            return null;
        }

        const prompt = this.createProductAnalysisPrompt(productImage, profile);
        console.log('üìù Generated analysis prompt:');
        console.log(prompt);

        try {
            const response = await this.safeSendMessage({
                action: 'aiPrompt',
                prompt: prompt,
                options: { temperature: 0.3, maxRetries: 1 }
            }, 10000);

            if (response.success) {
                console.log('ü§ñ AI Response:', response.response);
                const parsed = this.parseProductAnalysisResponse(response.response);
                console.log('üìä Parsed result:', parsed);
                return parsed;
            } else {
                console.error('‚ùå AI request failed:', response.error);
                return null;
            }
        } catch (error) {
            console.error('‚ùå Error testing prompt:', error);
            return null;
        }
    }
    
    // Debug method to inspect current page structure
    debugPageStructure() {
        console.log('üîç DEBUG: Page Structure Analysis');
        console.log('üìÑ Current page:', {
            url: this.currentUrl,
            host: this.currentHost,
            site: this.currentSite.name,
            pageType: this.pageType
        });
        
        // Test total images
        const allImages = document.querySelectorAll('img');
        console.log(`üì∏ Total images on page: ${allImages.length}`);
        
        // Sample some image sources for inspection
        console.log('üîç Sample image sources:');
        Array.from(allImages).slice(0, 10).forEach((img, i) => {
            console.log(`  ${i+1}. src: ${img.src}`);
            console.log(`     alt: "${img.alt}"`);
            console.log(`     class: "${img.className}"`);
            console.log(`     size: ${Math.round(img.getBoundingClientRect().width)}x${Math.round(img.getBoundingClientRect().height)}`);
        });
        
        // Test our selectors manually
        console.log('üéØ Testing site-specific selectors:');
        this.currentSite.selectors.productImages.forEach(selector => {
            const count = document.querySelectorAll(selector).length;
            console.log(`  ${selector}: ${count} matches`);
        });
        
        console.log('üì¶ Testing product card selectors:');
        this.currentSite.selectors.productCards.forEach(selector => {
            const count = document.querySelectorAll(selector).length;
            console.log(`  ${selector}: ${count} matches`);
        });
        
        return {
            totalImages: allImages.length,
            sampleImages: Array.from(allImages).slice(0, 5).map(img => ({
                src: img.src,
                alt: img.alt,
                className: img.className,
                dimensions: img.getBoundingClientRect()
            }))
        };
    }
    
    addExtensionIndicator() {
        // Remove any existing indicator
        const existing = document.getElementById('ai-style-filter-indicator');
        if (existing) {
            existing.remove();
        }
        
        // Create a site-specific indicator
        const indicator = document.createElement('div');
        indicator.id = 'ai-style-filter-indicator';
        indicator.innerHTML = `
            <div style="
                position: fixed;
                top: 10px;
                right: 10px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 8px 12px;
                border-radius: 20px;
                font-size: 12px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-weight: 500;
                z-index: 10000;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                cursor: pointer;
                transition: all 0.2s ease;
            ">
                üëï AI Style Filter - ${this.currentSite.name} (${this.pageType})
            </div>
        `;
        
        const indicatorElement = indicator.firstElementChild;
        
        // Add hover effect
        indicatorElement.addEventListener('mouseenter', () => {
            indicatorElement.style.transform = 'scale(1.05)';
        });
        indicatorElement.addEventListener('mouseleave', () => {
            indicatorElement.style.transform = 'scale(1)';
        });
        
        // Click to open dashboard
        indicatorElement.addEventListener('click', () => {
            chrome.runtime.sendMessage({action: 'openDashboard'});
        });
        
        document.body.appendChild(indicator);
        
        // Auto-fade after 3 seconds
        setTimeout(() => {
            if (document.getElementById('ai-style-filter-indicator')) {
                indicatorElement.style.opacity = '0.3';
            }
        }, 3000);
    }
    
    setupMessageListeners() {
        chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
            console.log('Content script received message:', request);
            
            switch (request.action) {
                case 'filterProducts':
                    console.log('Received filter products request');
                    sendResponse({
                        status: 'ready',
                        site: this.currentSite.name,
                        pageType: this.pageType
                    });
                    break;
                    
                case 'getPageInfo':
                    sendResponse({
                        host: this.currentHost,
                        site: this.currentSite,
                        pageType: this.pageType,
                        url: this.currentUrl
                    });
                    break;
                    
                case 'detectProducts':
                    this.detectProductImages().then(() => {
                        sendResponse({
                            status: 'detection_complete',
                            results: this.getDetectionStats()
                        });
                    });
                    return true; // Keep message channel open for async response
                    
                case 'getDetectionStats':
                    sendResponse({
                        status: 'success',
                        stats: this.getDetectionStats()
                    });
                    break;
                    
                case 'enableDebugMode':
                    this.enableDebugMode();
                    sendResponse({status: 'debug_enabled'});
                    break;
                    
                case 'clearDetection':
                    this.clearProductDetection();
                    sendResponse({status: 'detection_cleared'});
                    break;
                    
                case 'debugPageStructure':
                    const debugInfo = this.debugPageStructure();
                    sendResponse({status: 'debug_complete', data: debugInfo});
                    break;

                case 'analyzeProducts':
                    if (this.detectedProducts && this.detectedProducts.length > 0) {
                        const productElements = this.detectedProducts.map(item => item.element);
                        this.analyzeMultipleProducts(productElements).then(results => {
                            sendResponse({
                                status: 'analysis_complete',
                                results: results,
                                stats: this.analysisStats
                            });
                        });
                        return true; // Keep message channel open for async response
                    } else {
                        sendResponse({
                            status: 'no_products',
                            message: 'No detected products to analyze'
                        });
                    }
                    break;

                case 'getAnalysisStats':
                    sendResponse({
                        status: 'success',
                        stats: this.analysisStats,
                        cacheSize: this.analysisCache.size,
                        profileLoaded: !!this.userStyleProfile
                    });
                    break;

                case 'clearAnalysisCache':
                    this.clearAnalysisCache();
                    sendResponse({status: 'cache_cleared'});
                    break;

                case 'reloadStyleProfile':
                    this.loadUserStyleProfile().then(() => {
                        sendResponse({
                            status: 'profile_reloaded',
                            hasProfile: !!this.userStyleProfile
                        });
                    });
                    return true; // Keep message channel open for async response

                case 'debugAnalysisQueue':
                    const queueInfo = this.debugAnalysisQueue();
                    sendResponse({
                        status: 'debug_complete',
                        queueInfo: queueInfo
                    });
                    break;

                case 'resetAnalysisState':
                    this.resetAnalysisState();
                    sendResponse({status: 'state_reset'});
                    break;

                case 'enableViewportAnalysis':
                    this.enableViewportAnalysis();
                    sendResponse({status: 'viewport_analysis_enabled'});
                    break;

                case 'disableViewportAnalysis':
                    this.disableViewportAnalysis();
                    sendResponse({status: 'viewport_analysis_disabled'});
                    break;

                case 'debugCache':
                    const cacheInfo = this.debugCache();
                    sendResponse({
                        status: 'debug_complete',
                        cacheInfo: cacheInfo
                    });
                    break;

                case 'getCacheStatusForImage':
                    if (request.imageSrc) {
                        const img = document.querySelector(`img[src="${request.imageSrc}"]`);
                        if (img) {
                            const status = this.getCacheStatusForImage(img);
                            sendResponse({
                                status: 'cache_status_complete',
                                imageStatus: status
                            });
                        } else {
                            sendResponse({
                                status: 'image_not_found',
                                message: 'Image with specified src not found'
                            });
                        }
                    } else {
                        sendResponse({
                            status: 'missing_parameter',
                            message: 'imageSrc parameter required'
                        });
                    }
                    break;

                default:
                    sendResponse({status: 'unknown_action'});
            }
        });
    }
    
    setupNavigationListener() {
        // Handle SPA navigation for dynamic content loading
        let lastUrl = this.currentUrl;
        
        // Use MutationObserver to detect URL changes
        const observer = new MutationObserver(() => {
            if (window.location.href !== lastUrl) {
                lastUrl = window.location.href;
                this.currentUrl = lastUrl;
                
                console.log('üîÑ Navigation detected, reinitializing...', lastUrl);
                
                // Update page type detection
                this.pageType = this.detectPageType();
                
                // Reinitialize for new page
                this.initializeForPageType();
                
                // Update indicator
                this.addExtensionIndicator();
                
                // Re-run product detection after navigation
                setTimeout(async () => {
                    await this.detectProductImages();
                }, 2000);
                
                // Notify background script
                this.notifyBackgroundScript();
            }
        });
        
        // Start observing
        observer.observe(document, {
            childList: true,
            subtree: true
        });
        
        // Also listen for popstate events (back/forward navigation)
        window.addEventListener('popstate', () => {
            setTimeout(() => {
                if (window.location.href !== lastUrl) {
                    lastUrl = window.location.href;
                    this.currentUrl = lastUrl;
                    
                    console.log('üîÑ Popstate navigation detected, reinitializing...', lastUrl);
                    
                    this.pageType = this.detectPageType();
                    this.initializeForPageType();
                    this.addExtensionIndicator();
                    
                    // Re-run product detection after popstate navigation
                    setTimeout(async () => {
                        await this.detectProductImages();
                    }, 2000);
                    
                    this.notifyBackgroundScript();
                }
            }, 100);
        });
    }
    
    setupLazyLoadingDetection() {
        // Observe for new images being added to the DOM (lazy loading)
        const imageObserver = new MutationObserver((mutations) => {
            let hasNewImages = false;
            
            mutations.forEach((mutation) => {
                // Check for new img elements
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        if (node.tagName === 'IMG') {
                            hasNewImages = true;
                        } else if (node.querySelectorAll) {
                            const images = node.querySelectorAll('img');
                            if (images.length > 0) {
                                hasNewImages = true;
                            }
                        }
                    }
                });
                
                // Check for src attribute changes (lazy loading)
                if (mutation.type === 'attributes' && 
                    mutation.attributeName === 'src' && 
                    mutation.target.tagName === 'IMG') {
                    hasNewImages = true;
                }
            });
            
            // Re-run detection if new images found
            if (hasNewImages) {
                console.log('üñºÔ∏è New images detected, checking for new products...');
                setTimeout(async () => {
                    await this.detectNewProductImages();
                }, 500);
            }
        });
        
        // Start observing
        imageObserver.observe(document, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['src', 'data-src']
        });
        
        // Also set up intersection observer for scroll-triggered detection
        if ('IntersectionObserver' in window) {
            const scrollObserver = new IntersectionObserver((entries) => {
                const hasNewVisibleImages = entries.some(entry =>
                    entry.isIntersecting &&
                    entry.target.tagName === 'IMG' &&
                    !entry.target.dataset.aiStyleDetected
                );
                
                if (hasNewVisibleImages) {
                    console.log('üëÅÔ∏è New images scrolled into view, checking for products...');
                    setTimeout(async () => {
                        await this.detectNewProductImages();
                    }, 1000);
                }
            });
            
            // Observe all images
            setTimeout(() => {
                const allImages = document.querySelectorAll('img');
                allImages.forEach(img => {
                    scrollObserver.observe(img);
                });
            }, 2000);
        }
    }
    
    notifyBackgroundScript() {
        // Notify background script that content script is active
        chrome.runtime.sendMessage({
            action: 'contentScriptActive',
            data: {
                host: this.currentHost,
                site: this.currentSite.name,
                pageType: this.pageType,
                url: this.currentUrl,
                timestamp: Date.now()
            }
        }).catch(error => {
            console.log('Note: Background script not available:', error);
        });
    }
}

// Initialize the content script
const styleFilter = new StyleFilterContentScript();

// Export for testing
if (typeof module !== 'undefined' && module.exports) {
    module.exports = StyleFilterContentScript;
}